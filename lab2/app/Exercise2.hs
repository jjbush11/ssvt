module Exercise2 where

import Test.QuickCheck
import LTS
import Exercise1
import Control.Monad


-- A generator for IOLTSs
-- It generates a list of states, input labels, output labels, transitions and an initial state
-- The IOLTSs generated by this might contain states that are unreachable
randomIOLTS :: Gen IOLTS
randomIOLTS = do
  -- States should be unique and non-empty, thus we use listOf1
  states <- listOf1 (arbitrary `suchThat` (> 0))
  -- Input and output labels are not allowed to be the same
  -- Thus input labels are all lowercase and output labels are all uppercase
  inputLabels <- listOf1 $ listOf1 (elements ['a'..'z'])
  outputLabels <- listOf1 $ listOf1 (elements ['A'..'Z'])
  transitions <-  listOf1 (do
    s <- elements states
    l <- elements (inputLabels ++ outputLabels)
    s' <- elements states
    return (s, l, s'))
  initialState <- elements states
  return (states, inputLabels, outputLabels, transitions, initialState)


-- A generator for IOLTSs
-- It generates a list of states, input labels, output labels, transitions and an initial state
-- The IOLTSs generated by this will contain all possible transitions between the states
-- This makes for some interesting visualizations
allPossibleTransitionslIOLTS :: Gen IOLTS
allPossibleTransitionslIOLTS = do
  -- States should be unique and non-empty, thus we use listOf1
  -- We also limit the number of states to 5, to allow for the IOLTS to be generated in a reasonable amount of time
  states <- listOf1 (arbitrary `suchThat` (> 0) `suchThat` (< 5))
  -- Input and output labels are not allowed to be the same
  -- Thus input labels are all lowercase and output labels are all uppercase
  inputLabels <- listOf1 $ listOf1 (elements ['a'..'z'])
  outputLabels <- listOf1 $ listOf1 (elements ['A'..'Z'])
  let allPossibleTransitions = [(s, label, s') |
                                  s <- states,
                                  s' <- states,
                                  s' == s + 1,
                                  label <- inputLabels ++ outputLabels]
  initialState <- elements states
  return (states, inputLabels, outputLabels, allPossibleTransitions, initialState)


main :: IO ()
main = do
  -- All IOLTSs generated by randomIOLTS are valid according to the validateLTS function
  -- This does however, not necessarily mean that the IOLTSs make sense
  -- This can be seen when visualizing the IOLTSs
  quickCheck $ forAll randomIOLTS validateLTS
  someLTS <- generate randomIOLTS
  print $ validateLTS someLTS

  -- All IOLTSs generated by allPossibleTransitionslIOLTS are valid according to the validateLTS function
  -- All states are reachable by at least one transition
  -- The IOLTSs have a lot of transitions, which makes them hard to visualize, but it shows an interesting pattern
  quickCheck $ forAll allPossibleTransitionslIOLTS validateLTS


-- Time Spent: 1 hour