module Exercise3 where

import Data.Graph.Inductive
import Data.List
import LTS
import Test.QuickCheck
import Exercise2

-- Convert an IOLTS to a graph
-- This was initialy written because we thought we would be able to use the fgl library's bfs function 
-- to find all the quiescent traces of an IOLTS
convertIOLTSToGraph :: IOLTS -> Gr State Label
convertIOLTSToGraph (states, inputLabels, outputLabels, transitions, initialState) = mkGraph nodes edges
  where
    nodes = zip [1 ..] states
    edges = map (\(s, label, s') -> (fromIntegral s, fromIntegral s', label)) transitions

-- Add a delta transition from a quiescent state to itself, using the queiescentStates function
-- For Graphs
addQuiescentTransitionsToGraph :: IOLTS -> Gr State Label -> Gr State Label
addQuiescentTransitionsToGraph lts graph = insEdges quiescentTransitions graph
  where
    quiescentTransitions = map (\state -> (fromIntegral state, fromIntegral state, "delta")) (quiescentStates lts)

-- A a state without output actions, where s cannot autonomously proceed, is called suspended or quiescent.
-- As such a quiet state is a state where no output actions can be performed.
-- We can find the quiet states by finding the states where there are no outgoing transitions with output labels.
isQuiescentState :: IOLTS -> State -> Bool
isQuiescentState (states, inputLabels, outputLabels, transitions, initialState) state = null outgoingTransitions
  where
    outgoingTransitions = filter (\(s, label, _) -> s == state && label `elem` outputLabels) transitions

-- Find all quiescent states of an IOLTS, by making use of the isQuiescentState function
quiescentStates :: IOLTS -> [State]
quiescentStates lts@(states, inputLabels, outputLabels, transitions, initialState) = filter (isQuiescentState lts) states

-- Add a delta transition from a quiescent state to itself, using the queiescentStates function
addQuiescentTransitions :: IOLTS -> IOLTS
addQuiescentTransitions lts@(states, inputLabels, outputLabels, transitions, initialState) = (states, inputLabels, outputLabels, transitions ++ quiescentTransitions, initialState)
  where
    quiescentTransitions = map (\state -> (state, "delta", state)) (quiescentStates lts)

-- Try to find all quiescent traces of an IOLTS
-- Quiescent transitions are added to the LTS, by making use of the addQuiescentTransitions function
-- The traces function is then applied to the LTS, which will find all traces of the LTS
-- Our idea was to then filter out the traces that contain a delta transition, to find the quiescent traces
-- However, this does not follow the definition of a quiescent trace, as a quiescent trace is a trace that
-- might potentially contain a delta transition in the future, not a trace that contains a delta transition. 
straces :: IOLTS -> [Trace]
straces lts = traces (states, labels, transitions, initialState)
  where
    (states, inputLabels, outputLabels, transitions, initialState) = addQuiescentTransitions lts
    labels = nub $ inputLabels ++ outputLabels ++ ["delta"]


-- A random traces generator
-- It makes use of the allPossibleTransitionslIOLTS generator from Exercise2
-- And one of the first 10 traces of the IOLTS is chosen
-- This is done because the set of suspension traces of the specification can be infinite
randomTrace :: Gen Trace
randomTrace = do
  iolts <- allPossibleTransitionslIOLTS
  let traces = straces iolts
  elements (take 10 traces)

-- A list of all Tretman IOLTSs
tretmanK :: [IOLTS]
tretmanK = [tretmanK1, tretmanK2, tretmanK3]

tretmanI :: [IOLTS]
tretmanI = [tretmanI1, tretmanI2, tretmanI3, tretmanI4]

tretmanS :: [IOLTS]
tretmanS = [tretmanS1, tretmanS2, tretmanS3, tretmanS4]

tretmanRs :: [IOLTS]
tretmanRs = [tretmanR1, tretmanR2]

main :: IO ()
main = do
  print "Quiestent states of tretmanK"
  mapM_ (print . quiescentStates) tretmanK
  print "Quiestent states of tretmanI"
  mapM_ (print . quiescentStates) tretmanI
  print "Quiestent states of tretmanS"
  mapM_ (print . quiescentStates) tretmanS
  print "Quiestent states of tretmanR"
  mapM_ (print . quiescentStates) tretmanRs
  print "Suspension traces of tretmanK"
  -- Ghaffari
  -- The set of suspension traces of the specification is usually infinite. There
  -- are two reasons that can make it infinite: one is presence of loops in the specification and the other
  -- is that there could be label parameters on the transitions that can be instantiated from an infinite
  -- domain of values.
  -- Because of this we have to make use of the take function, to only print the first 5 traces
  let something = map (take 5 . straces) tretmanK
  mapM_ (print) something

  -- Print a trace which was generated by the random trace generator
  print "A random trace"
  trace <- generate randomTrace
  print trace

-- Time Spent: 6 hours